#include <msp430.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <libTimer.h>
#include <lcdutils.h>
#include <lcddraw.h>
#include <shape.h>
#include <abCircle.h>
#include "button.h"
#include "tone.h"
#define GREEN_LED BIT6
#define RED_LED BIT0

// keeps score
char scoreText[8] = "Score: ";
int score = 0;

AbRect rect10 = {abRectGetBounds, abRectCheck, {10,10}}; /**10x10 rectangle */
AbRArrow rightArrow = {abRArrowGetBounds, abRArrowCheck, 30};

AbRectOutline fieldOutline = {
  abRectOutlineGetBounds, AbRectOutlineCheck,
  {screenWidth/2 - 10, screenHeight/2 - 10}
};

Layer fieldLayer = { /*playing field as a layer */
  (AbShape *) &fieldOutline,
  {screenWidth/2, screenHeight/2}, /**<center */
  {0,0}, {0,0},
  COLOR_BLACK,
  0
};

Layer layerBall = { /**layer with moving ball */
  (AbShape *)&circle5,
  {(screenWidth/2)+10, (screenHeight/2)+5},
   {0,0}, {0,0},
  COLOR_VIOLET,
  &fieldLayer,  
};

Layer paddle = { /* layer with paddle */
  (AbShape *)&rect8,
  {screenWidth/2)+10, (screenHeight/2)+5},
  {0,0}, {0,0},
  COLOR_BLUE,
  &layerBall,
};

/** Moving Layer
 *  Linked list of layer references
 *  Velocity represents one iteration of change (direction & magnitude)
 */

typedef struct MovLayer_s {
  Layer *layer;
  Vec2 Velocity;
  struct MovLayer_s *next;
} MovLayer;

MovLayer ball = {&ballLayer, {0,0}, 0};
MovLayer paddle = {&paddle, {1,0}, &ball};

void movLayerDraw(MovLayer *movLayers, Layer *layers){
  int row, col;
  MovLayer *movLayer;

  and_sr(~8);
  for (movLayer = movLayers; movLayer; movLayer->next){
    Layer *l = movLayer->layer;
    l->posLast = l->pos;
    l->pos = l->posNext;
  }
  or_sr(8);        /** disable interrupts (GIE on) */

    for (movLayer = movLayers; movLayer; movLayer = movLayer->next) { /* for each moving layer */
    Region bounds;
    layerGetBounds(movLayer->layer, &bounds);
    lcd_setArea(bounds.topLeft.axes[0], bounds.topLeft.axes[1], 
		bounds.botRight.axes[0], bounds.botRight.axes[1]);
    for (row = bounds.topLeft.axes[1]; row <= bounds.botRight.axes[1]; row++) {
      for (col = bounds.topLeft.axes[0]; col <= bounds.botRight.axes[0]; col++) {
	Vec2 pixelPos = {col, row};
	u_int color = bgColor;
	Layer *probeLayer;
	for (probeLayer = layers; probeLayer; 
	     probeLayer = probeLayer->next) { /* probe all layers, in order */
	  if (abShapeCheck(probeLayer->abShape, &probeLayer->pos, &pixelPos)) {
	    color = probeLayer->color;
	    break; 
	  } /* if probe check */
	} // for checking all layers at col, row
	lcd_writeColor(color); 
      } // for col
    } // for row
  } // for moving layer being updated
}	  

